#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include "DatabaseReader.h"
#include "DataTypes.h"
#include "CSVRow.h"
#include "ReadFile.h"


/**
 * Overide stream operator for reading from our CSVRow class.
 *
 * @param str Stream to read from
 * @param data Our CSVRow object
 * @return Stream containing row
 */
std::istream& operator >> (std::istream& str, CSVRow& data)
{
    data.readNextRow(str);
    return str;
}

/**
 * Helper function to read all necessary databases.
 *
 * @return N/A
 */
void DatabaseReader::init()
{
    readAPIDList();
    readDatabase("databases/scdatabase.csv");
    readDatabase("databases/atmsdatabase.csv");
    readDatabase("databases/ompsdatabase.csv");
    readDatabase("databases/ceresdatabase.csv");
}

/**
 * Extracts byte and bit integers out of byte:bit string from database column.
 *
 * @param bytebit "byte:bit" string read from database
 * @param i_byte Unsigned 32-bit integer to be set by function
 * @param i_bitLower Unsigned 32-bit integer to be set by function
 * @param i_bitUpper Unsigned 32-bit integer to be set by function
 * @return None. Parameters serve as the return value
 */
void DatabaseReader::getByteBit(std::string& bytebit, uint32_t& i_byte, uint32_t& i_bitLower, uint32_t& i_bitUpper) const
{
    bytebit.erase(0, 1); // Remove leading /
    bytebit.erase(std::remove_if(bytebit.begin(), bytebit.end(), isspace), bytebit.end());  // Remove any whitespace from the string
    std::string s_byte = bytebit.substr(0, 4);
    try
    {
        i_byte = std::stoi(s_byte);
    }
    catch(...)
    {
        std::cerr << "stoi failed for i_byte: " << bytebit << std::endl;
    }
    if (bytebit.length() > 4)  // If longer than 4, then we have a bit range
    {
        std::string s_bit = bytebit.substr(5);  // Substring to end of string
        if (s_bit.length() > 1)
        {
            size_t found;
            if ((found = s_bit.find("-")) != std::string::npos)  // Split (x-y) range
            {
                try
                {
                    i_bitLower = std::stoi(s_bit.substr(0, found));
                    i_bitUpper = std::stoi(s_bit.substr(found + 1));
                }
                catch(...)
                {
                    std::cerr << "stoi failed for i_bitLower or i_bitUpper: " << bytebit << std::endl;
                }
            }
        }
        else  // Otherwise we have just a single bit
        {
            try
            {
                i_bitLower = std::stoi(s_bit);
            }
            catch (...)
            {
                std::cerr << "i_bitLower stoi failed with: " << bytebit << std::endl;
            }
            i_bitUpper = i_bitLower;
        }
    }
}

/**
 * Open CXXParams.csv generated by the Python script. Contains the selected APIDS.
 * Load APIDs into a vector.
 *
 * @return NA
 */
void DatabaseReader::readAPIDList()
{
    std::ifstream CXXParams(m_paramsFile);
    ReadFile::checkFile(CXXParams, m_paramsFile);

    CSVRow apidRow;
    while (CXXParams >> apidRow)
    {
        for (size_t cell = 0; cell < apidRow.size(); ++cell)
        {
            m_APIDs.emplace_back(std::stoi(apidRow[cell]));
        }
    }
}

/**
 * Read a database file. Generate a DataTypes::Entry struct for each row.
 *
 * @param filename Database file to open
 * @return N/A
 */
void DatabaseReader::readDatabase(const std::string& filename)
{
    std::ifstream database(filename);
    ReadFile::checkFile(database, filename);

    CSVRow dataRow;
    while (database >> dataRow)
    {
        if (m_firstRun) //Skip header row
        {
            m_firstRun = false;
            continue;
        }

        std::string mnem = dataRow[0];
        std::string s_APID = dataRow[2];
        std::string bytebit = dataRow[3];
        DataTypes::Entry tmp = defaults;
        uint32_t i_APID = 0;

        s_APID.erase(0, 4);  // Remove APID string from ex. (APID0001)

        try
        {
            i_APID = std::stoul(s_APID);
        }
        catch (...)
        {
            std::cout << "i_APID stoul failed for: " << s_APID << std::endl;
        }

        if(!m_allAPIDs)  // If filtering APIDs
        {
            if (std::find(m_APIDs.begin(), m_APIDs.end(), i_APID) == m_APIDs.end())  // If not found in selected vector
            {
                tmp.ignored = true;
            }
        }

        tmp.mnemonic = mnem;
        tmp.type = DataTypes::hashIt(dataRow[1].substr(0, 1));
        tmp.i_APID = i_APID;

        uint32_t i_byte = 0;
        uint32_t i_bitLower = 0;
        uint32_t i_bitUpper = 0;
        getByteBit(bytebit, i_byte, i_bitLower, i_bitUpper);

        tmp.byte = i_byte;
        tmp.bitLower = i_bitLower;
        tmp.bitUpper = i_bitUpper;
        tmp.length = std::stoi(dataRow[1].substr(1, std::string::npos));

        if (bannedAPID(mnem))  // Skip entries containing header info, as we already decode it.
        {
            tmp.ignored = true;
        }

        m_entries.emplace_back(tmp);
    }
    m_firstRun = true;
}

/**
 * Debug function to print what contents were read from the database.
 *
 * @return N/A
 */
void DatabaseReader::printDataBase() const
{
    for (const auto& entry : m_entries)
    {
        std::cout << entry.mnemonic << "," << entry.type << "," << entry.i_APID << "," << entry.byte << "," << entry.bitLower << "," << entry.bitUpper << "\n";
    }
}

/**
 * Getter function for member vector containing all entries.
 * Output is sorted before being returned.
 *
 * @return Sorted Entry vector
 */
std::vector<DataTypes::Entry> DatabaseReader::getEntries()
{
    auto sortLambda = [] (const DataTypes::Entry& a, const DataTypes::Entry& b) -> bool
    {
        if (a.i_APID != b.i_APID)
            return a.i_APID < b.i_APID;
        else
        {
            if (a.byte != b.byte)
                return a.byte < b.byte;
            else
                return a.bitLower < b.bitLower;
        }
    };
    std::sort(m_entries.begin(), m_entries.end(), sortLambda);
    return m_entries;
}

/**
 * Database contains entries for decoding Primary and Secondary header information. As this information is already hardcoded, these entries can be ignored.
 * This function skips entries containing header information.
 * @param mnem Mnemonic to check
 * @return True if we should skip this mnemonic
 */
bool DatabaseReader::bannedAPID(const std::string& mnem) const
{
    std::string strippedmnem;
    if (mnem.length() > 6)
        strippedmnem = mnem.substr(0, 1) + mnem.substr(5);
    else
        return false;
    if (std::find(m_skip.begin(), m_skip.end(), strippedmnem) != m_skip.end())
    {
        return true;
    }
    else
    {
        return false;
    }
}
